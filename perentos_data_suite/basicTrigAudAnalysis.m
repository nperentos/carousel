function out = basicTrigAudAnalysis(fle)

%% GENERATE AND SAVE THE DATA IN THE PERIPHERALS VARIABLE FOR LATER PROCESSING
    chNames{42} = {'PFC', 'M2s','CA1','Aud','PFCs', 'epith', 'accel-X','accel-Y','accel-Z', 'mic','resp','std'};
    chNames{43} = {'PFC', 'PFCs','CA1','Aud','M2s', 'epith', 'accel-X','accel-Y','accel-Z', 'mic','std', 'resp'};
    chNames{44} = {'PFC', 'M2s','Aud','CA1','PFCs', 'epith', 'accel-X','accel-Y','accel-Z', 'mic', 'std',  'resp'};
    %chNames{i} = {'PFC', 'M2s','Aud','CA1','PFCs', 'epith', 'accel-X','accel-Y','accel-Z', 'mic', 'resp'};
    eeg = logical([ 1 1 1 1 1 1 1 1 1 1 1 1]);
    %processedPath = getFullPath(fle); %chPeriph!
    processedPath = getfullpath(fle); %chPeriph!
    cd(processedPath);

    if exist([fle,'.dat'])
       display('OK - I found converted data')
       display('proceding with basic analysis')
    else
       error('you must first convert the data to *.dat before analysis');
    end

    % lets convert data to matlab format for further processing
    if exist([processedPath,'peripherals.mat'],'file') == 2
       disp '>loading preprocessed peripherals<';
       load([processedPath,'peripherals.mat']);1
    else

    % bring in the lfp data 
        disp 'get the LFP data';
        [data,settings,tScale] = getLFP(fle);
        %data([11],:)=[]; %I get rid of std channel 
        % in some cases I have to delete the emppty channels because of the
        % wrong settings in xml file of OE
        %data([1 2 3 4 6 8 11 9 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 36 37 38 39 40 41],:)=[];
        %data([4 5 6 11 34],:]) = [];
        %data = zscore(data')';
        [chanTypes] = getChanTypes(settings);

    % filter the respiration pressure sensor
        disp 'extract and filter the nasal pressure sensor signal';
        chPeriph = find(chanTypes == 2); % this type is the ADC channel which is the pressure sensor
        chPeriph = [size(data,1)-1 size(data,1) ];
        resp = data(chPeriph(2),:); % provided that your map includes only 2 ADC channels which should be the case mostly
        resp = filter_lfp(resp, 1000, [1 5]);

                        
        
    % lets extract the micrpohne but with 30k SR so that we can filterfigure; plot(mic); hold on(plot(mic2);
        % appropriately
        disp 'extract and process the microphone time series';
        [mic,settings30k,tScale30k] = getDAT(fle,chPeriph(2)); % this should be the microphone for single headstage
        [mic,settings30k,tScale30k] = getDAT(fle,10); % this should be the microphone - HAVE TO MANUALLY ENTER THE CHANNEL NUMBER!!! E.G. 10
        mic = filter_lfp(mic,30e3,[100, 0]);
        mic = abs(hilbert(mic));
        mic = mic(1:30:end);
        data(10,:) = zscore(mic);
        mic = eegfilt(mic,30e3,6e3, 10e3);

    % get the events reported back from python sound stim script
        [ev] = getMessageEvents(fle); % these events are in dat samples which is 30kHz
        ofs = ev(1); % this is needed to correct the stupid offset of all_channels.events
        ev = ev-ev(1); ev(1) = [];
        ev = round(ev); % now they match the LFP time series
        warning('setting event triggers to -50ms before the actual triggers - if you corrected the python script so that TTL is generate before sound, please remove this!!!');        
        ev = ev - 0;
        MakeEvtFile(ev, [getfullpath(fle),fle,'.aud.evt'],'aud',30e3,1);close all; eegplot([data([chPeriph],:);tmp.*SIGMA],'srate',1000,'color','on');

    % the events that are generated by the phase detector are not veryeegplot([data([chRpl],:);tmp.*SIGMA],'srate',1000);
        % useful but one could retrieve them like so
        ifRun = 0;
        if ifRun
           dataPath = getFullPath(fle);
           [evPhaseDetector, evPhaseDetectorTimestamps, info] = load_open_ephys_data([fullfile(dataPath,'all_channels.events')]);
            MakeEvtFile((evPhaseDetectorTimestamps-[ofs/30000])*1000, [getfullpath(fle),fle,'tmp','.tmp.evt'],1000,1);
           %MakeEvtFile(evPhaseDetectorTimestamps*1000, [getfullpath(fle),fle,'.tup.evt'],'tup',1000,1);
           %evPhaseDetectorTimestamps(info.eventId == 1) = [];
           %MakeEvtFile(evPhaseDetectorTimestamps, [getfullpath(fle),fle,'.tdn.evt'],'tdn',1000,1);
           
        end

    % extract the phase of the respiration cycledataPath = getFullPath(fle);
        [resp_phase ~] = extract_lfp_phase(resp);


    % lets save the data in peripherals.mat
        disp 'saving preprocessing data into peripherals.mat';
        save([processedPath,'peripherals.mat'],'data','mic','ev','resp','resp_phase', 'chNames', '-v7.3');
    end

%% spectrogram of respiratory cannula signal 
    respSignal = data(3,:);
    options.defaults = 'theta';
    SpResp = specmt(respSignal,options);
    figure; subplot(212);
    imagesc(SpResp.t',SpResp.f',(SpResp.Sxy)');
    hold on; caxis([ 0 1000]); hold on; axis xy; 
    
    % show integrated accelerometer value on a sample by sample basis
    intAcc = zscore(sum(abs(hilbert(data(7,:))),1));
    subplot(211); plot(tScale,intAcc); 
    linkaxes(get(gcf,'Children'),'x')
    axis tight

%% Triggered all LFPs around the sound stimuli
[audEv,excluded] = trig_lfp(data,ev/30, 500);
figure;
for i = 1:11
    subplot(3,4,i);
    
    shadedErrorBar([-.5:0.001:.5],mean(squeeze(audEv(i,:,:)),2),std(squeeze(audEv(i,:,:)),[],2)./sqrt(size(audEv,3)));
    axis tight; title(chNames{43}{i});
    hold on;
    plot([0 0], ylim,'--r');
end


%% Derive a movement/immobility variable from accelerometers and trigger that on the stimuli
[acc_std acc_t]= RunningFun(data(7:9,:)',@std, 5000, 5000);
figure;plot(acc_t,mean(acc_std,2));


%% select events based on movement or not
acc = sum(abs(zscore(data(7:9,:)')'),1)./3;

[trig_mov,excluded] = trig_lfp(acc,ev/30, 200);
%figure; plot(trig_mov');
% index of movement or not (integrade 200 ms after events)
s_mov = max(trig_mov(:,201:400),[],2);
figure; hist(s_mov,100)
thr_mov = prctile(s_mov,10);
movIdx = zeros(size(s_mov));
movIdx(s_mov>thr_mov) = 1;
figure; 
subplot(211); plot(trig_mov(movIdx == 0, :)');
subplot(212); plot(trig_mov(movIdx == 1, :)');for j = 1:2
    figure;
    l = length(movIdx(movIdx == j-1))
    for i = 1:11
        subplot(3,4,i);
        shadedErrorBar([-.5:0.001:.5],mean(squeeze(audEv(i,:,movIdx == j-1)),2),std(squeeze(audEv(i,:,movIdx == j-1)),[],2)./sqrt(l));
        axis tight; title(chNames{42}{i});
        hold on;
        plot([0 0], ylim,'--r');
    end
    mtit(num2str(j));
end

% now we can replot the triggered LFPs but split by movement or not
for j = 1:2
    figure;
    l = length(movIdx(movIdx == j-1))
    for i = 1:11
        subplot(3,4,i);
        shadedErrorBar([-.5:0.001:.5],mean(squeeze(audEv(i,:,movIdx == j-1)),2),std(squeeze(audEv(i,:,movIdx == j-1)),[],2)./sqrt(l));
        axis tight; title(chNames{42}{i});
        hold on;
        plot([0 0], ylim,'--r');
    end
    mtit(num2str(j));
end

%%

% detect slow wave events that exceed 3 standard deviations AND are
% accompanied by low accelerometer activity
for i = 2:2
    if eeg(i)
        [tmpData] = filter_lfp(data(i,:),1000,[0.1,4]);
        tmpData = zscore(tmpData);

        [SWpk{i}, SWidx{i}] = findpeaks(-tmpData,1000,'MinPeakDistance',0.25);%,'Threshold',3);
    else
        SWpk{i} = nan; SWidx{i} = nan;
    end
end

% things that anton suggested
% PCA of triggered LFPs to extract different types of responses
% divide events according to sigma power that precedes them
% divide events according to respiration cyle they fall into
% divide events according to level of accelerometers




function [position, direction, position_context] = getCarouselPosition(ch,events,tpe,fileBase)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [position, direction, position_context] = getCarouselPosition(ch,events,tpe,fileBase)
% extracts position and direction of travel on the carousel. It does not
% save any files atm. 
% INPUTS: ch: the time series of carousel encoder pulses at .dat rate!
%         events: events structure as generated by getRewardrs or getEvents
%         tpe: behavior type 0: none, 1: continuous and 2: passive
%         fileBase, optional fileBase, used for extracting sampling rates
%         in case they are not the defaults 30k/1000 Hz.
% OUTPUTS: position: an array the size of the lfp with binned position
%          direction: a character array with e.g. 'LRLLLR' sequences
%          signifying the direction of rotation of the carousel. This is
%          mainly useful for the passive carousel travel case or for the
%          cued direction which is yet to be implemented in this script.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% PRE
    decflag = 1;
    fprintf('computing position and direction of travel...\n');

    if nargin <3
        error('three inputs needed, minimum');
    end

    if ~any([tpe ~= 0, tpe ~= 1, tpe ~= 2])
        error('tpe can only be 0 (i.e. no task), 1 (i.e. continuous task) or 2 (i.e. passive task)')
    end

    if nargin < 4
        display 'no fileBase provided so will go for default sampling rates (.lfp=1000Hz and .dat=30000Hz)');
        div = 30; 
    else
        tic
        processedPath = getfullpath(fileBase);
        cd(processedPath);
        pth = fullfile(getfullpath(fileBase),[fileBase,'.lfp']);
        par = LoadXml([pth(1:end-4),'.xml']);
        SR_LFP = par.lfpSampleRate;
        SR_WB = par.SampleRate;
        div = SR_WB/SR_LFP;
        % length of the LFP file to avoid surprises
        tmp = dir([par.FileName,'.lfp']);
        sz = tmp.bytes/par.nChannels/2;
    end


    % isPassive = 0;
    % if nargin >= 4 
    %     if strcmp(tpe, 'passive')
    %         isPassive = 1;
    %     else        
    %         display('task type empty using default, non passive');
    %     end
    % end

    % this input was used for the SiNAPS IIT data n
    % if nargin == 5
    %     decflag = decmate;
    % else
    %     decflag = 1;
    % end

    %warning('computation of ''location'' on carousel relies on correct interpretation of TTLs, especially the start point pulse sequence');

    if isstr(events)
        if strcmp(events, 'no pulses available') || tpe == 0
            disp('there are no rewards so assuming that the carousel did not spin'); 
            position = zeros(1,sz); 
            direction  = ['none'];
            position_context  = ['none'];
            figure; text(0.1,0.5,'there was no carousel movement');
            xlim([0 1]);ylim([0 1]);
            print(fullfile(getfullpath(fileBase),'position_report'),'-djpeg','-r300');
            %position = 'there was no carousel movement'; 
            %direction  = 'there was no carousel movement'; 
            return;        
        end
    end; 
    % lets get the TTL markers - used for position resetting
    exp = [events.atStart' events.atCW' events.atACW';
        2*ones(length(events.atStart),1)' 1*ones(length(events.atCW),1)' 3*ones(length(events.atACW),1)']';
    [~,idx]=sort(exp(:,1));
    exp = exp(idx,:);


    % now lets create a direction variable based on the sequence of pulses we
    % get whereby: 
    %               2 pulses (Start point) -> 3 pulses (RHS cage) -> 1 pulse  (LHS cage) = clockwise rotation
    %               2 pulse  (Start point) -> 1 pulse  (LHS cage) -> 3 pulses (RHS cage) = anticlockwise
    cpts = find(exp(:,2)==2);
    prev = exp(cpts-1,2);
    prev(prev == 3) = 'R';
    prev(prev == 1) = 'L';
    direction = char(prev);
    %direction = ['LLLRRLLLRRLRRLRLLRRLLRLRLRLRRLRLLLRRLRRL']; % sesh: '/storage2/perentos/data/recordings/IIT/DAY2/NP30_2019-04-10_12-58-38
    %direction = ['LRLRLLRRRLLRLRRRLRLL']'; some day 1 IIT session
    % direction = ['RRLRLRLRLRLRLRLRLRLRLRLRLRRRRRRRRRRRRRRLRLRLRLRLRLRLRLRLLRLR'];
    %direction = ['LLRLLLRLRRRLLLRLRRLR']'; % forceddirections for IIT b/c of missing pulses (bad arduino code)
    %direction = ['RRRLLRRRLLRLLRLRRLLRRLLLRLRLLRLRRRLLRLLR']';
    clear prev;

% extract location
% extract angular location on carousel based on rotary encoder pulses and
% knowledge of the starting/reset point defined as the time of start
% point reward/sound. Older recordings relied on a TTL that corresponded to
% Algorythm: Detect all positive crossings and mark them as 1 in an
% otherwise nan array. Then star coounting up till first start point TTL.
% If the first rotation was ACW, then replace the counts with counting
% down 0 till the first start TTL. From there one either reset to zero or
% start counting down 
% 

%% ACTIVE TASK
if tpe == 1 % continuous task - unidirectional only
    
    
    display('task is continuous, unidirection (closed loop)...');
    % find threshold crossings upwards
    if isvector(ch)
        if size(ch,1) > size(ch,2); ch = ch'; end 
        idxl = ch>max(ch)*.75;
        idx = [idxl(2:end),0];
        idxn = idx-idxl; 
        idxn(idxn==-1)=0; % keep up crossings
        position = idxn;
        position(position == 0) = nan;

        % fill in pulses with incremental integers: 
        % there are four cases. If the sequence is L followed by R then we
        % go from 4k to 0 and from 0 to 4k. If the sequence is R followed
        % by L then we go from 0 4k and from 4k down to zero. If its L L,
        % then we go from 4k to 0 and then jump to 4k and count to 0 once
        % more. If its R R, then we go from 0 to 4k, then jump to zero
        % again and count up to 4k once more.

        % first rotation is special case for now
        tmp2 = 30*events.atStart(1); % where to stop looking for pulses
        tmp1 = 1;% where to start looking for pulses
        fill = find(position(tmp1:tmp2) == 1); % the indices of points to fill

        % for the first trial
        vals = linspace(0,2*pi,length(fill));
        if direction(1) == 'L'      
            vals = fliplr(vals);
            for j = tmp1:1:length(fill)
                position(fill(j)) = length(fill)-j+1; % in pulses - which varies from trial to trial
                position(fill(j)) = vals(j); % with adaptive resolution of 360/length(fill)
            end
        elseif direction(1) == 'R'
            for j = tmp1:1:length(fill)
                position(fill(j)) = vals(j);
            end
        end 
        last = fill(end);

        % for remaining trials  
        for i = 2:length(events.atStart)            
            tmp1 = 30*events.atStart(i-1);% previous end or rotation
            tmp2 = 30*events.atStart(i);%current end of rotation
            fill = tmp1 -1 + find(position(tmp1:tmp2) == 1); % indices of pulses within relevant range
            vals = linspace(0,2*pi,length(fill));

            if direction(i-1) == 'R' & direction(i) == 'L' % count up from 4k
                vals = fliplr(vals);
                down_from = position(last);
                for j = 1:1:length(fill)
                    position(fill(j)) = vals(j);
                end
            elseif direction(i-1) == 'R' & direction(i) == 'R' % count up from zero
                for j = 1:1:length(fill)
                    position(fill(j)) = vals(j);
                end
            elseif direction(i-1) == 'L' & direction(i) == 'R' % count up from zero
                for j = 1:1:length(fill)
                    position(fill(j)) = vals(j);
                end
            elseif direction(i-1) == 'L' & direction(i) == 'L' % count up from zero in the reverse direction
                vals = fliplr(vals);
                for j = 1:1:length(fill)
                    position(fill(j)) = vals(j);
                end             
            end
            last = fill(end);
        end
        a = position;
        a = [0 0 a];
        b = [a(2:end),inf];
        from = find(~isnan(a) & isnan(b)) + 1;
        to   = find(~isnan(b) & isnan(a));
        idxFiller = from - 1;
        % fill nans with preceding number
        for i = 1:length(from)
            a(from(i):to(i)) = a(idxFiller(i));
        end
        position = a(3:end);
        if decflag
            position = downsample(position,30);
        end
        position_context = ['none'];
    else
        error('must supply vector not matrix i.e. one channel only)');        
    end
    figure('pos',[100 100 1700 1400]); 
    subplot(211); jplot(position); axis tight;
    subplot(212);text(.5,.5,'active task - no context chunks');axis([0 1 0 1]);
    stampFig(fileBase);
    print(fullfile(getfullpath(fileBase),'position_report'),'-djpeg','-r300');
%% PASSIVE TASK    
elseif tpe == 2 %% the task was passive 
    
    
    display('task is controlled, bidirectional (open loop)...');
    if isvector(ch)    
    % get the carousel pulses
        if size(ch,1) > size(ch,2); ch = ch'; end 
        % guard against absence of pulses
        if range(ch) < 3000 || (max(ch)<0 && min(ch) < 0) % there are no pulses
            position = nan(1,length(ch));
            %position = resample(position,1,30);
            warning('there appear to be no pulses in this recording. Setting carouselSpeed to NaN...');
            backFill = 0;
        else
            idxl = ch>max(ch)*.75;
            idx = [idxl(2:end),0];
            idxn = idx-idxl; 
            idxn(idxn==-1)=0; % keep up crossings
            position = idxn;
            position(position == 0) = nan;
            backFill = 1;
        end

        % lets try here a bit differently to below but maybe easier
        % start by finding the return to origin point (events = 2) which i the
        % end of the trial. Then also find the time point of the arrival to the
        % target. This is the inbound trajectory. Therefore these pulses need
        % to be filled in as 
        yes = 1;ofs = 1;
        if backFill
            while yes
            % end of trial
                trialEnd = find(events.all(ofs:end,2) == 2,1)+ofs-1;
                t_trialEnd = events.all(trialEnd,1);
                t_trialEnd = find(position(1:t_trialEnd + floor(SR_WB/3)),1,'last')+1; % account for carousel intertia
            % beginning of trial
                if ofs == 1 % first trial
                    t_strt = find(position == 1,1);
                else % all other trials
                    %t_strt = find(events.all(1:trialEnd,2) == 2,2); t_strt = t_strt(2);            
                    t_strt =  t_trialEnd_prev+1;
                end
            % target arrival
                target = events.all(trialEnd-1,2); % target type (will be 1[left] or 3[right])    
                t_target = events.all(trialEnd - 1,1); % index of arrival to the target
                t_target = find(position(1:t_target + floor(SR_WB/3)),1,'last');% account for carousel intertia
            % CW positive and ACW negative
                if target == 1; 
                    mlt = 1; 
                elseif target == 3; 
                    mlt = -1; 
                else
                    error('maybe there are 4 pulse events in the passive task? Cannot deal with this atm...'); 
                end
            % fill in from t_start to t_target incrementing upwards
                clear toFill;
                toFill = find(position(t_strt:t_target) == 1) + t_strt - 1;
                position(toFill) = [1:1:length(toFill)].*mlt;
            % fill in from t_target to t_trialEnd incrementing downwards
                clear toFill;
                toFill = find(position(t_target+1:t_trialEnd) == 1) + t_target;  
                position(toFill) = fliplr([1:1:length(toFill)]).*mlt;
            % start point of search for next trial     
                ofs = trialEnd + 1; % this is for the next trial
                t_trialEnd_prev = t_trialEnd;
            % is this the last trial?
                if trialEnd == length(events.all)
                    yes = 0;
                end
            end
        end
        display('filling in positions between pulses...');
        % fill in mising values with previous
        a = position;
        a = [0 0 a];
        b = [a(2:end),inf];
        from = find(~isnan(a) & isnan(b)) + 1;
        to   = find(~isnan(b) & isnan(a));
        idxFiller = from - 1;
        % fill nans with preceding number
        for i = 1:length(from)
            a(from(i):to(i)) = a(idxFiller(i));
        end
        position = a(3:end); 
        position = downsample(position,div);    

        % get transitions of carousel since position is not enough - we need to
        % know the context as well i.e. inbound vs outbound
        ipt = findchangepts(position([1:10:end]),'Statistic','linear','MaxNumChanges',length(events.all)*2);    
        ipt = ipt*10;
        % from this lets extract the slop for each segment
        tmp_ipt = [1 ipt length(position)];
        for i = 1:length(tmp_ipt)-1
            seg = position(tmp_ipt(i):tmp_ipt(i+1));
            slp(i) = (seg(end)-seg(1))/length(seg);
            mu(i) = mean(seg);
        end
        % negative mean and negative slope is approach to right
        toR = find(slp<-0.2 & mu<-200);clr(toR) = 1;
        % negative mean and positive slope is return to origin from right
        fromR = find(slp>0.2 & mu<-200);clr(fromR) = 2;
        % positive mean and positive slope is approach to left
        toL = find(slp>0.2 & mu>200);clr(toL) = 3;
        % positive mean and negative slope is return to orogin from left
        fromL = find(slp<-0.2 & mu>200);clr(fromL) = 4;
        % 0 mean and 0 slope is wait at origin
        atO = find(slp<0.1 & slp>-0.1 & mu>-200 & mu<200);clr(atO) = 5;
        % negative mean and 0 slope is waiting at right
        atR = find(slp<0.1 & slp>-0.1 & mu < -1000);clr(atR) = 6;
        % positive mean and 0 slope is waiting at left
        atL = find(slp<0.1 & slp>-0.1 & mu > 1000);clr(atL) = 7;
        % just to confirm that we captured all of them
        %sort([toR fromR toL fromL atO atL atR])
        % turn position into radians
        % position = position.*(deg2rad(120)/max(abs(position)));
        % a single pulse should correspond to: 
        ENA = [];[ena, dio]=findpeaks(position);ENA = [ENA,ena];[ena, dio]=findpeaks(-position); ENA = [ENA,ena];
        ENA(ENA<=0) = [];
        d = mode(ENA);% this is our closest guess of what corresponds to 120 degrees
        deg_per_pulse = 120/d;
        position = deg2rad(position.*deg_per_pulse);
        %position = position.*(deg2rad(120)/max(abs(position)));
        figure('pos',[100 100 1700 1400]); 
        subplot(211); jplot(position); axis tight;
        subplot(212);
        gscatter(mu,slp,clr);
        title('contextual chunks');
        xlabel('mean position (-ve right, +ive left)');
        ylabel('slope(-ve right, +ive left)');
        legend('toR', 'fromR', 'toL', 'fromL', 'atO', 'atL', 'atR');
        stampFig(fileBase);
        print(fullfile(getfullpath(fileBase),'position_report'),'-djpeg','-r300');
        position_context.segs = [tmp_ipt(1:end-1);tmp_ipt(2:end)]';
        position_context.context = clr;
        position_context.labels = ['1:toR', '2:fromR', '3:toL', '4:fromL', '5:atO', '6:atR', '7:atL'];
        
    else
        error('must supply vector not matrix i.e. one channel only)');        
    end
else
    error('maybe this is a cued direction task? Code is not implement for this yet');
end
fprintf('DONE\n');    
    
        
        
% below is a passive task position computation where inbound and outbound
% trajectories to either directions are encoded in unique positional
% values (i.e. the middle of the left bound trajectroey would take one
% value when inbound and another value for outbound. I will try to change
% this so that it is encoded as the try position This could be done post
% hoc maybe but iside the function?? Bellow I save the code that works
%  display('the task is controlled, bydirectional (open loop).');
%     display(' ');
%     display('_____________________________________________________________________________________ ');
%     display('In passive task 0 to ~(+3.5k) is a |CW rotation| and 0 to ~(-3.5k) is a |ACW rotation|');
%     display('                                   |  R(ight)  |                        |   L(eft)   |');
%     display('                                   |     1     |                        |     0      |');
%     display('out- & in-bound are interpreted as 0-1.7k as outbound and 1.7-3.5k as inbound        |');
%     display('_____________________________________________________________________________________ ');
%     display('NOTE THAT THE PASSIVE TASK POSITION IS STILL ENCODED IN PULSES INSTEAD OF DEGREES !!! ');
%         % find threshold crossings upwards
%     if isvector(ch)
%         if size(ch,1) > size(ch,2); ch = ch'; end 
%         idxl = ch>max(ch)*.75;
%         idx = [idxl(2:end),0];
%         idxn = idx-idxl; 
%         idxn(idxn==-1)=0; % keep up crossings
%         position = idxn;
%         position(position == 0) = nan;
% 
%         % fill in pulses with incremental integers: 
%         % there are two cases, L and R
% 
%         % first rotation is special case for now
%         tmp2 = 30*events.atStart(1); % where to stop looking for pulses
%         tmp1 = 1;% where to start looking for pulses
%         fill = find(position(tmp1:tmp2) == 1); % the indices of points to fill
% 
%         % for the first trial
%         k = 0;
%         if direction(1) == 'L'
%             for j = tmp1:1:length(fill)
%                 position(fill(j)) = -(k+1);
%                 k = k+1;
%             end
%         elseif direction(1) == 'R'
%             for j = tmp1:1:length(fill)
%                 position(fill(j)) = j;
%             end
%         end 
%         last = fill(end);
% 
%         % for remaining trials  
%         for i = 2:length(events.atStart)            
%             tmp1 = 30*events.atStart(i-1);% previous end or rotation
%             tmp2 = 30*events.atStart(i);%current end of rotation
%             fill = tmp1 -1 + find(position(tmp1:tmp2) == 1); % indices of pulses within relevant range
% 
%             if direction(i) == 'L' % count down from 'last'
%                 for j = 1:1:length(fill)
%                     position(fill(j)) = - j;
%                 end
%             elseif direction(i) == 'R' % count up from 'last'
%                 for j = 1:1:length(fill)
%                     position(fill(j)) =  + j;
%                 end           
%             end
%             
%             last = fill(end);
%             
%         end
%         a = position;
%         a = [0 0 a];
%         b = [a(2:end),inf];
%         from = find(~isnan(a) & isnan(b)) + 1;
%         to   = find(~isnan(b) & isnan(a));
%         idxFiller = from - 1;
%         % fill nans with preceding number
%         for i = 1:length(from)
%             a(from(i):to(i)) = a(idxFiller(i));
%         end
%         position = a(3:end); 
%         position = downsample(position,30);
%     else
%         error('must supply vector not matrix i.e. one channel only)');        
%     end

        
%% below is a working version with number of pulses
% if nargin <2
%     error('two inputs needed, carousel encoder channel number and rewards structure array')  
% end
% 
% if ~isPassive
%     % find threshold crossings upwards
%     if isvector(ch)
%         if size(ch,1) > size(ch,2); ch = ch'; end 
%         idxl = ch>max(ch)*.75;
%         idx = [idxl(2:end),0];
%         idxn = idx-idxl; 
%         idxn(idxn==-1)=0; % keep up crossings
%         location = idxn;
%         location(location == 0) = nan;
% 
%         % fill in pulses with incremental integers: 
%         % there are four cases. If the sequence is L followed by R then we
%         % go from 4k to 0 and from 0 to 4k. If the sequence is R followed
%         % by L then we go from 0 4k and from 4k down to zero. If its L L,
%         % then we go from 4k to 0 and then jump to 4k and count to 0 once
%         % more. If its R R, then we go from 0 to 4k, then jump to zero
%         % again and count up to 4k once more.
% 
%         % first rotation is special case for now
%         tmp2 = 30*events.atStart(1); % where to stop looking for pulses
%         tmp1 = 1;% where to start looking for pulses
%         fill = find(location(tmp1:tmp2) == 1); % the indices of points to fill
% 
%         % for the first trial
%         if direction(1) == 'L'                
%             for j = tmp1:1:length(fill)
%                 location(fill(j)) = length(fill)-j+1;
%             end
%         elseif direction(1) == 'R'
%             for j = tmp1:1:length(fill)
%                 location(fill(j)) = j;
%             end
%         end 
%         last = fill(end);
% 
%         % for remaining trials  
%         for i = 2:length(events.atStart)            
%             tmp1 = 30*events.atStart(i-1);% previous end or rotation
%             tmp2 = 30*events.atStart(i);%current end of rotation
%             fill = tmp1 -1 + find(location(tmp1:tmp2) == 1); % indices of pulses within relevant range
% 
% 
%             if direction(i-1) == 'R' & direction(i) == 'L' % count up from 4k
%                 down_from = location(last);
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = down_from-j;
%                 end
%             elseif direction(i-1) == 'R' & direction(i) == 'R' % count up from zero
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = j;
%                 end
%             elseif direction(i-1) == 'L' & direction(i) == 'R' % count up from zero
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = j;
%                 end
%             elseif direction(i-1) == 'L' & direction(i) == 'L' % count up from zero in the reverse direction
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = length(fill)-j+1;
%                 end             
%             end
%             last = fill(end);
%         end
%         a = location;
%         a = [0 0 a];
%         b = [a(2:end),inf];
%         from = find(~isnan(a) & isnan(b)) + 1;
%         to   = find(~isnan(b) & isnan(a));
%         idxFiller = from - 1;
%         % fill nans with preceding number
%         for i = 1:length(from)
%             a(from(i):to(i)) = a(idxFiller(i));
%         end
%         location = a(3:end);
%         if decflag
%             location = decimate(location,30);
%         end
%     else
%         error('must supply vector not matrix i.e. one channel only)');        
%     end
%     
% else %% the task was passive  

%%

% this one works in degrees directly instead of counting pulses forcing the
% number the range to be between 0-2pi irrespective of the number of pulses
% if nargin <2
%     error('two inputs needed, carousel encoder channel number and rewards structure array')  
% end
% 
% if ~isPassive
%     % find threshold crossings upwards
%     if isvector(ch)
%         if size(ch,1) > size(ch,2); ch = ch'; end 
%         idxl = ch>max(ch)*.75;
%         idx = [idxl(2:end),0];
%         idxn = idx-idxl; 
%         idxn(idxn==-1)=0; % keep up crossings
%         location = idxn;
%         location(location == 0) = nan;
% 
%         % fill in pulses with incremental integers: 
%         % there are four cases. If the sequence is L followed by R then we
%         % go from 4k to 0 and from 0 to 4k. If the sequence is R followed
%         % by L then we go from 0 4k and from 4k down to zero. If its L L,
%         % then we go from 4k to 0 and then jump to 4k and count to 0 once
%         % more. If its R R, then we go from 0 to 4k, then jump to zero
%         % again and count up to 4k once more.
% 
%         % first rotation is special case for now
%         tmp2 = 30*events.atStart(1); % where to stop looking for pulses
%         tmp1 = 1;% where to start looking for pulses
%         fill = find(location(tmp1:tmp2) == 1); % the indices of points to fill
% 
%         % for the first trial
%         vals = linspace(0,2*pi,length(fill));
%         if direction(1) == 'L'      
%             vals = fliplr(vals);
%             for j = tmp1:1:length(fill)
%                 location(fill(j)) = length(fill)-j+1; % in pulses - which varies from trial to trial
%                 location(fill(j)) = vals(j); % with adaptive resolution of 360/length(fill)
%             end
%         elseif direction(1) == 'R'
%             for j = tmp1:1:length(fill)
%                 location(fill(j)) = vals(j);
%             end
%         end 
%         last = fill(end);
% 
%         % for remaining trials  
%         for i = 2:length(events.atStart)            
%             tmp1 = 30*events.atStart(i-1);% previous end or rotation
%             tmp2 = 30*events.atStart(i);%current end of rotation
%             fill = tmp1 -1 + find(location(tmp1:tmp2) == 1); % indices of pulses within relevant range
%             vals = linspace(0,2*pi,length(fill));
% 
%             if direction(i-1) == 'R' & direction(i) == 'L' % count up from 4k
%                 vals = fliplr(vals);
%                 down_from = location(last);
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = vals(j);
%                 end
%             elseif direction(i-1) == 'R' & direction(i) == 'R' % count up from zero
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = vals(j);
%                 end
%             elseif direction(i-1) == 'L' & direction(i) == 'R' % count up from zero
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = vals(j);
%                 end
%             elseif direction(i-1) == 'L' & direction(i) == 'L' % count up from zero in the reverse direction
%                 vals = fliplr(vals);
%                 for j = 1:1:length(fill)
%                     location(fill(j)) = vals(j);
%                 end             
%             end
%             last = fill(end);
%         end
%         a = location;
%         a = [0 0 a];
%         b = [a(2:end),inf];
%         from = find(~isnan(a) & isnan(b)) + 1;
%         to   = find(~isnan(b) & isnan(a));
%         idxFiller = from - 1;
%         % fill nans with preceding number
%         for i = 1:length(from)
%             a(from(i):to(i)) = a(idxFiller(i));
%         end
%         location = a(3:end);
%         if decflag
%             location = downsample(location,30);
%         end
%     else
%         error('must supply vector not matrix i.e. one channel only)');        
%     end
%     
% else %% the task was passive 